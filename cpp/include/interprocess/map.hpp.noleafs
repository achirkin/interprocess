#include <interprocess/common.hpp>
#include <interprocess/shared_blob.hpp>

#include <array>
#include <atomic>
#include <cstddef>
#include <cstdint>

#pragma once

namespace interprocess {

template <typename From, typename To, typename = void>
struct is_reinterpretable : std::false_type {};

template <typename From, typename To>
struct is_reinterpretable<From, To,
                          std::void_t<decltype(reinterpret_cast<To>(std::declval<From>()))>>
    : std::true_type {};

template <typename From, typename To>
inline constexpr bool is_reinterpretable_v = is_reinterpretable<From, To>::value;  // NOLINT

/** Lock-free non-shrinking map */
template <std::uint8_t B, typename K, typename V>
class map_t {
 private:
  static constexpr auto get_depth_bits(std::uint8_t acc = 0) noexcept -> std::uint8_t {
    return std::size_t(kRadixBase << acc) >= kKeySize ? acc : get_depth_bits(acc + 1);
  }

 public:
  using key_type = K;
  using value_type = V;
  using pointer_t = std::int8_t*;
  using symbol_type = std::uint16_t;
  using index_type = std::uint32_t;

  static constexpr std::uint8_t kRadixBase = B;
  static constexpr key_type kRadixMask = key_type{(1 << kRadixBase) - 1};
  static constexpr std::size_t kKeySize = sizeof(key_type) * 8;
  static constexpr std::size_t kSymSize = sizeof(symbol_type) * 8;

  static_assert(kRadixBase <= kSymSize, "Radix base must fit in the symbol size.");

  static constexpr std::uint8_t kDepthBits = get_depth_bits();
  static constexpr std::uint8_t kDepthMask = std::uint8_t{(1 << kDepthBits) - 1};
  static constexpr std::uint8_t kDepthMax = div_rounding_up<std::size_t>(kKeySize, kRadixBase);
  static constexpr std::uint8_t kTrailingBits = (kKeySize + kRadixBase - 1) % kRadixBase + 1;
  static constexpr std::uint8_t kPrefixBits = kKeySize - kDepthBits;

  static_assert(kDepthBits <= kTrailingBits,
                "Tree depth is too big because the radix base is too small.");

  inline map_t() noexcept
      : blob_tree_{kNodesOffset + kBaseTreeSize * sizeof(node_t)},
        blob_leafs_{kBaseValsSize * sizeof(value_type)} {
    // initialize the desciption
    new (blob_tree_.data()) description_t{};
    // immutable dummy leaf
    get_nodes()[0] = node_t{0, kDepthMax};
    // dummy leaf node as a root
    get_nodes()[1] = node_t{0, kDepthMax};
    // The default value will be returned whenever the entry is missing
    get_leafs()[0] = value_type{};
  }

  auto get(key_type key) const noexcept -> value_type {
    INTERPROCESS_LOG_DEBUG("(%zu) Exec get for key %zu...\n", size_t(get_description().root),
                           size_t(key));
    auto nodes = get_nodes();
    auto leafs = get_leafs();
    return nodes[get_description().root].get(nodes, leafs, key);
  }
  void set(key_type key, value_type val) noexcept {
    INTERPROCESS_LOG_DEBUG("Exec set for key %zu...\n", size_t(key));
    auto nodes = get_nodes();
    auto leafs = get_leafs();
    auto& desc = get_description();
    auto& root = nodes[desc.root];
    root.set(desc, nodes, leafs, desc.root, key, val);
    INTERPROCESS_LOG_DEBUG("Exec set for key %zu... done!\n", size_t(key));
  }

  void report_size() const noexcept {
    auto& desc = get_description();
    auto n = desc.num_nodes.load();
    auto l = desc.num_leafs.load();
    // no-leaf-type: Nodes: 16, leafs: 15, total size: 16572 bytes
    printf("Nodes: %zu, leafs: %zu, total size: %zu bytes\n", size_t(n), size_t(l),
           sizeof(node_t) * n + sizeof(value_type) * l);
  }

 private:
  struct description_t {
    index_type root{1};
    std::atomic<index_type> num_nodes{2};
    std::atomic<index_type> num_leafs{1};
  };

  struct node_t {
    std::array<index_type, 1 << kRadixBase> children;
    key_type code;

    inline node_t(key_type key, std::uint8_t depth)
        : code{(key & ~key_type((1 << (kKeySize - depth * kRadixBase)) - 1)) | depth} {
      children.fill(0);
    }

    [[nodiscard]] inline auto depth() const noexcept -> std::uint8_t { return code & kDepthMask; }

    [[nodiscard]] inline auto match(key_type key) const noexcept -> bool {
      auto shift = kKeySize - depth() * kRadixBase;
      return (key >> shift) == (code >> shift);
    }

    [[nodiscard]] inline auto symbol(key_type key) const noexcept -> symbol_type {
      auto shift = kKeySize - (depth() + 1) * kRadixBase;
      return (key >> shift) & kRadixMask;
    }

    [[nodiscard]] inline auto get(const node_t* nodes, const value_type* leafs,
                                  key_type key) const noexcept -> value_type {
      if (!match(key)) {
        return leafs[0];
      }
      auto s = symbol(key);
      auto i = children[s];
      INTERPROCESS_LOG_DEBUG("(%zu@%zu) go get... depth = %zu (max: %zu)\n", size_t(i), size_t(s),
                             size_t(depth()), size_t(kDepthMax));
      return depth() >= kDepthMax ? leafs[i] : nodes[i].get(nodes, leafs, key);
    }
    /** Number of symbols matching between the current node and the given key. */
    [[nodiscard]] inline auto matching_depth(key_type key) const noexcept -> std::uint8_t {
      auto diff = (code ^ key) | kDepthMask;
      return clz(diff) / kRadixBase;
    }

    void set(description_t& description, node_t* nodes, value_type* leafs, index_type& node_source,
             key_type key, value_type val) noexcept {
      INTERPROCESS_LOG_DEBUG("(%zu) go set... depth = %zu (max: %zu)\n", size_t(node_source),
                             size_t(depth()), size_t(kDepthMax));
      if (match(key)) {
        INTERPROCESS_LOG_DEBUG("(%zu) Key: %zu, full match!\n", size_t(node_source), size_t(key));
        auto s = symbol(key);
        auto& i = children[s];  // TODO: atomic replace needed!
        if (depth() >= kDepthMax) {
          if (i == 0) {
            // Allocate a new value if the current is the default dummy.
            i = description.num_leafs.fetch_add(1, std::memory_order_relaxed);
          }
          leafs[i] = val;
        } else {
          if (i == 0) {
            auto j = description.num_nodes.fetch_add(1, std::memory_order_relaxed);
            auto& new_leaf = nodes[j];
            new_leaf = node_t{key, kDepthMax};
            INTERPROCESS_LOG_DEBUG("(%zu) create a new leaf (%zu/%zu)...\n", size_t(node_source),
                                   size_t(j), size_t(s));
            new_leaf.set(description, nodes, leafs, j, key, val);
            i = j;
          } else {
            INTERPROCESS_LOG_DEBUG("(%zu) go next branch...\n", size_t(node_source));
            nodes[i].set(description, nodes, leafs, i, key, val);
          }
        }
      } else {
        auto d = matching_depth(key);
        INTERPROCESS_LOG_DEBUG("(%zu) Key: %zu, matching depth: %zu.\n", size_t(node_source),
                               size_t(key), size_t(d));
        auto i = description.num_nodes.fetch_add(2, std::memory_order_relaxed);
        auto j = i + 1;
        auto& new_node = nodes[i];
        auto& new_leaf = nodes[j];
        new_node = node_t{key, d};
        new_leaf = node_t{key, kDepthMax};
        auto cur_child = new_node.symbol(code);
        auto new_child = new_node.symbol(key);
        INTERPROCESS_LOG_DEBUG("New node (%zu) with children (%zu/%zu, %zu/%zu)\n", size_t(i),
                               size_t(node_source), size_t(cur_child), size_t(j),
                               size_t(new_child));
        new_node.children[cur_child] = node_source;
        new_node.children[new_child] = j;
        new_leaf.set(description, nodes, leafs, j, key, val);
        node_source = i;  // TODO: atomic replace needed!
      }
    }
  };

  static constexpr std::size_t kBaseTreeSize = 32;
  static constexpr std::size_t kBaseValsSize = 256;
  static constexpr std::size_t kNodesOffset = round_up(sizeof(description_t), alignof(node_t));

  shared_blob_t blob_tree_;
  shared_blob_t blob_leafs_;

  [[nodiscard]] auto get_description() noexcept -> description_t& {
    return *reinterpret_cast<description_t*>(blob_tree_.data());
  }

  [[nodiscard]] auto get_description() const noexcept -> const description_t& {
    return const_cast<const description_t&>(
        const_cast<map_t<B, K, V>*>(this)->get_description());  // NOLINT
  }

  [[nodiscard]] auto get_nodes() noexcept -> node_t* {
    return reinterpret_cast<node_t*>(reinterpret_cast<std::byte*>(blob_tree_.data()) +
                                     kNodesOffset);
  }

  [[nodiscard]] auto get_nodes() const noexcept -> const node_t* {
    return const_cast<const node_t*>(const_cast<map_t<B, K, V>*>(this)->get_nodes());  // NOLINT
  }

  [[nodiscard]] auto get_leafs() noexcept -> value_type* {
    return reinterpret_cast<value_type*>(blob_leafs_.data());
  }

  [[nodiscard]] auto get_leafs() const noexcept -> const value_type* {
    return const_cast<const value_type*>(const_cast<map_t<B, K, V>*>(this)->get_leafs());  // NOLINT
  }
};

}  // namespace interprocess
